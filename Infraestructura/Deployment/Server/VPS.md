# VPS
Para este ejemplo se ha contratado un VPS con OVH, el mas basico con 1core de CPU, 1GB de RAM y 20GB de Almacenmiento, el despliegue se va a hacer con Docker.

Un VPS es un entorno virtualizado en un servidor de una empresa externa que contiene un sistema operativo instalado(en este caso debian) el cual tenemos que configurar en su totalidad.

## Primera toma de contacto 
Accedemos al portal de OVH
<img width="731" alt="image" src="https://github.com/g4rc1ss/ApuntesProgramacion/assets/28193994/f7703bf0-ff19-4c0a-a2c0-9f24461fa029">

Basicamente para lo que necesitamos estar aqui es para obtene los datos como la ip para acceder al servidor, para conectar con la maquina se realiza a traves de una conexion `SSH` y toda configuracion se hace mediante terminal o algun gestor GUI que lo permita.
- `sudo su`: para tener acceso root termporalmente y no andar metiendo `sudo` todo el rato(no es lo mas recomendable, la verdad)
- `apt-get update`: Actualizamos el registro de dependencias y sus versiones
- `apt-get upgrade`: Actualizamos las dependencias con las nuevas versiones del registro

> Tambien es recomendable ejecutar el comando `passwd` para cambiar la password, si es que nos han dado una por defecto(que suele ser lo habitual)

## Iptables
Para poder agregar un poco de seguridad, configuramos un firewall con `iptables`

Creamos un archivo llamado `iptables` y escribimos lo siguiente
```bash
# Generated by xtables-save v1.8.2 on Fri Jul 14 09:58:16 2023
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
:DOCKER - [0:0]
:DOCKER-ISOLATION-STAGE-1 - [0:0]
:DOCKER-USER - [0:0]
:DOCKER-ISOLATION-STAGE-2 - [0:0]
-A INPUT -i lo -j ACCEPT
# NGINX
-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -p udp -m udp --dport 53 -j ACCEPT
# grafana
-A INPUT -p tcp -m tcp --dport 3000 -j ACCEPT
# Zipkin
-A INPUT -p tcp -m tcp --dport 9411 -j ACCEPT
# SEQ
-A INPUT -p tcp -m tcp --dport 5341 -j ACCEPT
# Open Telemetry
-A INPUT -p tcp -m tcp --dport 8889 -j ACCEPT
# Prometheus
-A INPUT -p tcp -m tcp --dport 9090 -j ACCEPT
# API NodeJS
-A INPUT -p tcp -m tcp --dport 55434 -j ACCEPT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-USER -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
COMMIT
# Completed on Fri Jul 14 09:58:16 2023
# Generated by xtables-save v1.8.2 on Fri Jul 14 09:58:16 2023
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:DOCKER - [0:0]
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A DOCKER -i docker0 -j RETURN
COMMIT
```
Cargamos las reglas con el comando `sudo iptables-restore < archivoIptablesCreadoPorNosotros`.

> Para que se ejecuten las reglas cada vez que reiniciamos el servidor instalamos el paquete `iptables-persistent` y ejecutamos el comando `sudo iptables-save > /etc/iptables/rules.v4`

##  Despliegue de la app con DOCKER
En este ejemplo se va a desplegar una aplicacion .NET con Docker-Compose

Para poder desplegar la aplicacion con docker, aparte de tener docker, necesitamos el codigo que se va a desplegar junto con los dockerfile.

Hay varias formas de hacerlo:

### GITHUB
Lo mas comodo es hacer el deploy desde Github directamente a traves de procesos CI/CD, la idea es, crear una pipeline que compile la imagen a ejecutar en el servidor y enviar esa imagen al VPS para hacer el proceso de deploy

- [Pipe de CI/CD de deploy](https://github.com/g4rc1ss/Dotnet-Web-Clean-Architecture-Skeleton/blob/main/.github/workflows/deploy-hostwebapi.yml)
- [Script de deploy](https://github.com/g4rc1ss/Dotnet-Web-Clean-Architecture-Skeleton/blob/main/.docker/deploy.ps1)

Basicamente la CI/CD tiene configurados los entornos de DEV y PRO y se encarga de llamar al script de deploy

El script de deploy se encarga de compilar la imagen, subirla al servidor junto al docker-compose y los archivos que sean necesarios y hacer el proceso de deploy. Si el proceso de deploy falla por lo que sea, por ejemplo, porque se ha configurado mal y no devuelve healthy, se hará un rollback automático.

### SFTP
Si preferimos mandar directamente el codigo nosotros, se puede establecer una conexion `sftp` para la transferencia de ficheros.

Comprimimos nuestro proyecto en un zip por ejemplo para la transferencia y ejecutamos los comandos:
```bash
sftp usuario@direccion.ip
put /ruta/nuestro/archivo ./ruta/donde/colocarlo
```

Una vez tenemos el projecto en zip, lo descomprimimos con el comando `unzip` y ejecutamos el comando para crear la imagen `docker-compose -f archivo.yml build` y una vez construida la imagen, ejecutamos `docker-compose -f archivo.yml up -d` para desplegar el servicio.